@ct.lattice
def quantum_classical_workflow(train_path, test_path, train_batch, pytorch_optimizer, epochs, lr_c, lr_q, print_intermediate):

    # Run the classical sublattice
    results_classical, loss_history_classical, trained_net_c = \
         classical_workflow(train_path=pixel_train,
                            test_path=pixel_test,
                            train_batch=train_batch,
                            pytorch_optimizer=pytorch_optimizer,
                            epochs=epochs,
                            lr=lr_c,
                            print_intermediate=print_intermediate,
                            test_num_dat=None)

    # Run the quantum sublattice
    results_quantum, loss_history_quantum, trained_opt_q = \
         quantum_workflow(train_path=train_path,
                          test_path=test_path,
                          train_batch=train_batch,
                          pytorch_optimizer=pytorch_optimizer,
                          epochs=epochs,
                          lr=lr_q,
                          print_intermediate=print_intermediate,
                          test_num_dat=None)

    # Calculate the accuracy scores
    acc_classical = get_accuracy_score(results_classical)
    acc_quantum = get_accuracy_score(results_quantum)
    return (acc_classical, acc_quantum, trained_net_c, trained_opt_q,
            loss_history_classical, loss_history_quantum)


